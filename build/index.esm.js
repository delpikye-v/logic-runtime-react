import{atom as t,effect as e}from"chrono-state-z";import{createScope as s,createIntentBus as n}from"intentx-core-z";import*as i from"react";import{useSyncExternalStore as o}from"react";import{jsx as a}from"react/jsx-runtime";class r{constructor(){this.handlers={},this.effects={},this.middlewares=[]}use(t){this.middlewares.push(t)}effect(t,e){var s,n;(null!==(s=(n=this.effects)[t])&&void 0!==s?s:n[t]=[]).push(e)}on(t,e){var s,n;const i=this.handlers[t];i&&i.length>0?console.warn(`[IntentBus] Duplicate intent handler "${t}" detected. Only the first handler will be used.`):(null!==(s=(n=this.handlers)[t])&&void 0!==s?s:n[t]=[]).push(e)}async emit(t,e){var s,n;const i=null!==(s=this.handlers[t])&&void 0!==s?s:[],o=null!==(n=this.effects[t])&&void 0!==n?n:[],a=(r=this.middlewares,c=async t=>{t.effects=o;for(const e of i)await e(t)},r.reduceRight((t,e)=>e(t),c));var r,c;await a(e)}}class c{constructor(t,e=s("logic")){this.subs=new Set,this.bus=new r,this.dirty=!0,this.isComputing=!1,this.markDirty=()=>{this.dirty=!0,this.subs.forEach(t=>t())},this.getSnapshot=()=>(this.dirty&&(this.snapshotCache=this.buildSnapshot(),this.dirty=!1),this.snapshotCache),this.subscribe=t=>(this.subs.add(t),()=>this.subs.delete(t)),this.onIntent=(t,e)=>{this.bus.on(t,e)},this.emit=async(t,e)=>{const s=new AbortController;await this.bus.emit(t,{payload:e,scope:this.scope,signal:s.signal,state:this.getSnapshot,setState:t=>this.setStateInternal(t),emit:this.emit})},this.scope=e,this.atoms=this.createAtoms(t);for(const t in this.atoms)this.atoms[t].subscribe(this.markDirty);this.bus.use(function(){const t=new Map,e=new Map;return s=>async n=>{var i;const o=n.effects;if(!(null==o?void 0:o.length))return s(n);for(const s of o){const o=s.handler.toString();if("takeLatest"===s.strategy){null===(i=t.get(o))||void 0===i||i.abort();const e=new AbortController;t.set(o,e),await s.handler({...n,signal:e.signal})}else"debounce"===s.strategy?(clearTimeout(e.get(o)),e.set(o,setTimeout(()=>s.handler(n),s.wait))):await s.handler(n)}await s(n)}}())}createAtoms(e){const s={};for(const n in e)s[n]=t(e[n]);return s}buildSnapshot(){const t={};for(const e in this.atoms)t[e]=this.atoms[e]();return t}setStateInternal(t){this.isComputing&&console.warn("[logic-runtime] Side-effect detected: setState() called inside computed()");const e=this.buildSnapshot();t(e);for(const t in e)e[t]!==this.atoms[t]()&&this.atoms[t].set(e[t])}useEffect(t,e){this.bus.effect(t,e)}attachComputed(s,n){const i=t(void 0);e(()=>{this.isComputing=!0;const t=n();i.set(t),this.isComputing=!1}),this.atoms[s]=i,i.subscribe(this.markDirty)}}function u(t){const e={_kind:"effect",handler:t,strategy:"default",wait:0};return{...e,takeLatest(){return e.strategy="takeLatest",this},debounce(t){return e.strategy="debounce",e.wait=t,this}}}function l(t){return{name:t.name,create(e){var s;const n=new c(structuredClone(t.state),e);if(t.computed)for(const e in t.computed)n.attachComputed(e,()=>t.computed[e]({state:n.getSnapshot()}));null===(s=t.intents)||void 0===s||s.call(t,{on:n.onIntent,effect:n.useEffect.bind(n)});const i={};if(t.actions)for(const e in t.actions)i[e]=t.actions[e]({emit:n.emit,getState:n.getSnapshot});return n.actions=i,n}}}function h(t){return{create(){const e={};for(const s in t){const n=s;e[n]=t[n].create()}return{async emit(t,s){for(const n of Object.values(e))await n.emit(t,s)},subscribe(t){const s=Object.values(e).map(e=>e.subscribe(t));return()=>s.forEach(t=>t())},getSnapshot(){const t={};for(const s in e)t[s]=e[s].getSnapshot();return t}}}}}function f(t){const e=function(){let t=0,e=[];return{get records(){return e.slice()},record:function(s){e.push({...s,id:++t,state:structuredClone(s.state)})},replay:async function(t,s){const{from:n=0,to:i=1/0,scope:o}=null!=s?s:{},a=e.filter(t=>"emit"===t.type&&t.id>=n&&t.id<=i&&(!o||t.scope===o));for(const e of a){const s=t(e.intent,e.payload);s instanceof Promise&&await s}},clear:function(){e=[],t=0}}}();function s(){return"string"==typeof t.scope?t.scope:t.scope.name}return{timeline:e,wrap:function(){const n=t.emit.bind(t);t.emit=async(i,o)=>{e.record({type:"emit:start",intent:i,payload:o,scope:s(),state:t.getSnapshot(),timestamp:Date.now()});try{const t=n(i,o);t instanceof Promise&&await t}finally{e.record({type:"emit:end",intent:i,payload:o,scope:s(),state:t.getSnapshot(),timestamp:Date.now()})}}}}}function d(t){var e,i;let o=structuredClone(t);const a=()=>structuredClone(o),r=t=>{o=Object.assign(a(),t)},c=s("backend");async function u(t,e){await l.emit(t,e,c)}const l=n(t=>({payload:t,signal:(new AbortController).signal,state:a(),setState(){throw new Error("setState is not allowed in backend runtime")},emit:u}));function h(t,e,s){return{intent:t,payload:e,state:s.state,signal:s.signal,set:r,emit:u}}function d(t){return{state:t.state,signal:t.signal,set:t.set,emit:t.emit}}const m={state:()=>o,reset:()=>{o=structuredClone(t)},emit:u,registerIntents:function(t){for(const e in t){const s=t[e];l.on(e,async(t,n)=>{const i=d(h(e,n,t));await s(i)},c)}},onIntent:l.on,effect:l.effect};if("production"!==(null===(i=null===(e=null===globalThis||void 0===globalThis?void 0:globalThis.process)||void 0===e?void 0:e.env)||void 0===i?void 0:i.NODE_ENV)){const t=f(m);t.wrap(m),m.devtools=t}return m}function m(t,e=Object.is){let s,n=null;return i=>{if(null!==n){const o=t(i);return e(s,o)?s:(s=o,n=i,o)}return n=i,s=t(i),s}}function p(t){if(t instanceof c)return o(t.subscribe,t.getSnapshot,t.getSnapshot);const e=t.create(s("react"));return o(e.subscribe,e.getSnapshot,e.getSnapshot)}function g(t){if("actions"in t)return t.actions;return p(t).actions}function b(t,e){return o(t.subscribe,()=>e(t.getSnapshot()),()=>e(t.getSnapshot()))}function y(t,e,n){var o,r;const c=o=>{const r=i.useRef(null);r.current||(r.current=t.create("string"==typeof n?s(n):n));const c=r.current,u=i.useSyncExternalStore(c.subscribe,c.getSnapshot,c.getSnapshot),l=i.useCallback((t,e)=>c.emit(t,e),[c]),h=i.useMemo(()=>({state:u,actions:c.actions,emit:l}),[u,l,c]);return a(e,{...o,...h})};return c.displayName=`withLogic(${null!==(r=null!==(o=e.displayName)&&void 0!==o?o:e.name)&&void 0!==r?r:"View"})`,c}export{c as LogicRuntime,f as attachDevtools,h as composeLogic,d as createBackendRuntime,l as createLogic,m as createSelector,u as effect,g as useActions,p as useRuntime,b as useSelector,y as withLogic};
