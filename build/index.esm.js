import{jsx as t}from"react/jsx-runtime";import*as e from"react";function n(t){let e=t;const n=new Set;return{getState:function(){return e},setState:function(t){const r=e,o=structuredClone(r);t(o),Object.is(r,o)||(e=o,n.forEach(t=>t()))},subscribe:function(t){return n.add(t),()=>n.delete(t)}}}function r(){const t=new Map,e=new Map,n=new Map;return{compute:function(n,r,o){if(t.has(n))return t.get(n);const s=new Set,a=r({state:new Proxy(o,{get:(t,e,n)=>("string"==typeof e&&e in t&&s.add(e),Reflect.get(t,e,n))})});return t.set(n,a),e.set(n,s),a},invalidate:function(r){e.forEach((e,o)=>{var s;e.has(r)&&(t.delete(o),null===(s=n.get(o))||void 0===s||s.forEach(t=>t()))})},subscribe:function(t,e){var r;const o=null!==(r=n.get(t))&&void 0!==r?r:new Set;return o.add(e),n.set(t,o),()=>o.delete(e)},reset:function(){t.clear(),e.clear(),n.forEach(t=>t.forEach(t=>t()))}}}function o(t,e=Object.is){let n,r=null;return o=>{if(null!==r){const s=t(o);return e(n,s)?n:(n=s,r=o,s)}return r=o,n=t(o),n}}function s(t){let e=t;const n=new Set;return{get:()=>e,set(t){Object.is(e,t)||(e=t,n.forEach(t=>t()))},subscribe:t=>(n.add(t),()=>n.delete(t))}}function a(t){const e=new Map,n=new Map,r=[],o=new Map;return{on:function(t,n){var r;const o=null!==(r=e.get(t))&&void 0!==r?r:[];o.push(n),e.set(t,o)},effect:function(t,e){var r;const o=null!==(r=n.get(t))&&void 0!==r?r:[];o.push(e),n.set(t,o)},emit:async function(s,a,i){var c,l;const u=`${t}:${s}`;null===(c=o.get(u))||void 0===c||c.abort();const f=new AbortController;o.set(u,f);const d=Array.from(e.entries()).filter(([t])=>function(t,e){return t.endsWith("/*")?e.startsWith(t.slice(0,-2)):t===e}(t,s)).flatMap(([,t])=>t),p=null!==(l=n.get(s))&&void 0!==l?l:[];for(const e of d){let n=e;for(let t=p.length-1;t>=0;t--)n=p[t](n);const o={state:i.getState(),payload:a,signal:f.signal,scope:t,emit:i.emit,setState:i.setState};let s=-1;const c=async t=>{if(t<=s)throw new Error("next() called multiple times");s=t;const e=r[t];if(!e)return n(o);await e(o,()=>c(t+1))};await c(0)}},use:function(t){r.push(t)}}}function i(t){const e=function(){let t=0,e=[];return{get records(){return e.slice()},record:function(n){e.push({...n,id:++t,state:structuredClone(n.state)})},replay:async function(t,n){const{from:r=0,to:o=1/0,scope:s}=null!=n?n:{},a=e.filter(t=>"emit"===t.type&&t.id>=r&&t.id<=o&&(!s||t.scope===s));for(const e of a){const n=t(e.intent,e.payload);n instanceof Promise&&await n}},clear:function(){e=[],t=0}}}();return{timeline:e,wrap:function(){const n=t.emit.bind(t);t.emit=async(r,o)=>{e.record({type:"emit:start",intent:r,payload:o,scope:t.scope,state:t.state(),timestamp:Date.now()});try{await n(r,o)}finally{e.record({type:"emit:end",intent:r,payload:o,scope:t.scope,state:t.state(),timestamp:Date.now()})}}}}}var c,l;let u=0;const f="production"!==(null===(l=null===(c=null===globalThis||void 0===globalThis?void 0:globalThis.process)||void 0===c?void 0:c.env)||void 0===l?void 0:l.NODE_ENV);function d(t){var e;const o=null!==(e=t.name)&&void 0!==e?e:"logic";return{create(e){var s,c;const l=null!=e?e:`${o}:${++u}`,d=structuredClone(t.state),p=n(structuredClone(t.state)),m=r(),v=a(l);null===(s=t.intents)||void 0===s||s.call(t,v);let h=null,b=null,g=!1,y=new Set;const w=[],E=[];function S(){const e=p.getState();if(e===h&&b)return b;const n={};var r;return t.computed&&(r=t.computed,Object.keys(r)).forEach(r=>{n[r]=m.compute(r,t.computed[r],e)}),h=e,b=Object.assign({},e,n),b}function C(t){const e=p.getState();p.setState(n=>{t(n);for(const t in n)e[t]!==n[t]&&(g?y.add(t):m.invalidate(t))})}const j={scope:l,state:()=>S(),setState:C,reset(){!function(){var t;p.setState(()=>structuredClone(d)),null===(t=m.reset)||void 0===t||t.call(m),h=null,b=null}()},use:v.use,effect:v.effect,batch:function(t){g=!0;try{t()}finally{g=!1,y.forEach(t=>m.invalidate(t)),y.clear()}},async emit(t,e){const n=S();w.forEach(r=>r({intent:t,payload:e,state:n,scope:l}));try{await v.emit(t,e,{getState:S,setState:C,emit:j.emit})}finally{E.forEach(n=>n({intent:t,payload:e,state:S(),scope:l}))}},subscribe:p.subscribe,onIntent(t,e){v.on(t,e)},__internal:{onEmitStart(t){w.push(t)},onEmitEnd(t){E.push(t)}}};let O;return null===(c=t.plugins)||void 0===c||c.forEach(t=>t.setup(j)),f&&(O=i(j),O.wrap(j)),{...j,devtools:O}}}}function p(...t){return{create(e){const n=t.map(t=>{var n,r;if("logic"in t){const o=t.logic.create(null!==(n=t.namespace)&&void 0!==n?n:e);return{namespace:null!==(r=t.namespace)&&void 0!==r?r:null,inst:o}}return{namespace:null,inst:t.create(e)}});return{get state(){const t={};for(const{namespace:e,inst:r}of n){const n=r.state();e?t[e]=n:Object.assign(t,n)}return t},async emit(t,e){const r=n.map(n=>{var r,o;return null===(o=(r=n.inst).emit)||void 0===o?void 0:o.call(r,t,e)}).filter(Boolean);await Promise.all(r)},subscribe(t){const e=n.map(e=>e.inst.subscribe(t));return()=>e.forEach(t=>t())}}}}}function m(t){return e=>t.reduceRight((t,e)=>e(t),e)}function v(){let t=null;return e=>async n=>{if(null==t||t.abort(),t=new AbortController,!t.signal.aborted)return e({...n,signal:t.signal})}}function h(t){let e;return n=>r=>new Promise(o=>{clearTimeout(e),e=setTimeout(()=>o(n(r)),t)})}function b(t=3){return e=>async n=>{let r;for(let o=0;o<t;o++)try{return await e(n)}catch(t){if(n.signal.aborted)return;r=t}throw r}}function g(t){const e=[e=>async n=>{if(!n.signal.aborted)return await t(n),e(n)}];let n=!1;const r=t=>(n=!0,m(e))(t);return r.takeLatest=()=>{if(n)throw new Error("Effect already built");return e.push(v()),r},r.debounce=t=>{if(n)throw new Error("Effect already built");return e.push(h(t)),r},r.retry=(t=3)=>{if(n)throw new Error("Effect already built");return e.push(b(t)),r},r}function y(t){var e,n;let o=structuredClone(t);const s=r(),c=a("backend"),l=[],u=[];let f=!1,d=new Set;function p(t){const e=structuredClone(o);if(t(o),f)for(const t in o)e[t]!==o[t]&&d.add(t);else for(const t in o)e[t]!==o[t]&&s.invalidate(t)}function m(t){return{...t,set(t){p(e=>Object.assign(e,t))},emit:v.emit}}const v={state:()=>o,setState:p,batch:function(t){f=!0;try{t()}finally{f=!1,d.forEach(t=>s.invalidate(t)),d.clear()}},async emit(t,e){l.forEach(n=>n({intent:t,payload:e,state:structuredClone(o)}));try{await c.emit(t,e,{getState:()=>o,setState:p,emit:v.emit})}finally{u.forEach(n=>n({intent:t,payload:e,state:structuredClone(o)}))}},onIntent:c.on,effect:c.effect,use:c.use,registerIntents:function(t){for(const e in t){const n=t[e];c.on(e,async t=>{await n(m({state:o,signal:t.signal}))})}},__internal:{onEmitStart(t){l.push(t)},onEmitEnd(t){u.push(t)}},reset:function(){o=structuredClone(t),s.reset()}};if("production"!==(null===(n=null===(e=null===globalThis||void 0===globalThis?void 0:globalThis.process)||void 0===e?void 0:e.env)||void 0===n?void 0:n.NODE_ENV)){const t=i(v);t.wrap(v),v.devtools=t}return v}function w(t){return function(e,n){let r=-1;return function o(s){if(s<=r)return Promise.reject(new Error("next() called multiple times"));r=s;const a=t[s]||n;return a?Promise.resolve(a(e,()=>o(s+1))):Promise.resolve()}(0)}}function E(n,r,o){var s,a;const i=s=>{const a=e.useRef(null);a.current||(a.current=n.create(o));const i=a.current,c=e.useSyncExternalStore(i.subscribe,i.state,i.state),l=e.useCallback((t,e)=>i.emit(t,e),[i]);return t(r,{...s,state:c,emit:l})};return i.displayName=`withLogic(${null!==(a=null!==(s=r.displayName)&&void 0!==s?s:r.name)&&void 0!==a?a:"View"})`,i}export{i as attachDevtools,m as composeEffects,p as composeLogic,w as composeMiddleware,y as createBackendRuntime,r as createComputed,a as createIntentBus,d as createLogic,o as createSelector,s as createSignal,n as createStore,h as debounce,g as effect,b as retry,v as takeLatest,E as withLogic};
